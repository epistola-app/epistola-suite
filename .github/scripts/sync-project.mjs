#!/usr/bin/env node
/**
 * GitHub Project Sync
 *
 * Syncs project configuration from .github/project.yml to GitHub Projects v2.
 * Uses the gh CLI for GraphQL API calls.
 *
 * Required environment variable: GH_TOKEN
 * In CI, this is a GitHub App installation token generated by actions/create-github-app-token
 * using PROJECT_APP_ID and PROJECT_APP_PRIVATE_KEY secrets.
 *
 * @see https://docs.github.com/en/issues/planning-and-tracking-with-projects
 */

import {readFileSync} from 'fs';
import {execSync} from 'child_process';
import {parse} from 'yaml';

// =============================================================================
// Configuration
// =============================================================================

const CONFIG_PATH = '.github/project.yml';
const config = parse(readFileSync(CONFIG_PATH, 'utf8'));

// =============================================================================
// Logging Utilities
// =============================================================================

const log = {
  header: (msg) => console.log(`\n=== ${msg} ===\n`),
  info: (msg) => console.log(msg),
  success: (msg) => console.log(`  ✓ ${msg}`),
  warn: (msg) => console.warn(`  ⚠ ${msg}`),
  error: (msg) => console.error(`  ✗ ${msg}`),
  field: (name, status) => console.log(`  [${name}] ${status}`),
};

// =============================================================================
// GraphQL Client
// =============================================================================

/**
 * Escape a string for use in GraphQL inline values
 */
function escapeGraphQL(str) {
  return (str || '').replace(/\\/g, '\\\\').replace(/"/g, '\\"');
}

/**
 * Execute a GraphQL query using the gh CLI
 *
 * @param {string} query - GraphQL query or mutation
 * @param {Record<string, unknown>} variables - Query variables
 * @returns {object} The data portion of the GraphQL response
 * @throws {Error} If the query fails or returns errors
 */
function graphql(query, variables = {}) {
  // Build variable arguments: -f for strings, -F for non-strings
  const variableArgs = Object.entries(variables)
    .map(([key, value]) => {
      const flag = typeof value === 'string' ? '-f' : '-F';
      return `${flag} ${key}=${JSON.stringify(value)}`;
    })
    .join(' ');

  const escapedQuery = query.replace(/'/g, "'\\''");
  const cmd = `gh api graphql -f query='${escapedQuery}' ${variableArgs}`.trim();

  try {
    const result = execSync(cmd, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
    const parsed = JSON.parse(result);

    if (parsed.errors) {
      const errorMsg = parsed.errors.map((e) => e.message).join('; ');
      throw new Error(errorMsg);
    }

    return parsed.data;
  } catch (error) {
    // Enhance error with stdout if available
    if (error.stdout) {
      try {
        const response = JSON.parse(error.stdout);
        if (response.errors) {
          throw new Error(response.errors.map((e) => e.message).join('; '));
        }
      } catch {
        // Ignore parse errors, use original error
      }
    }
    throw error;
  }
}

/**
 * Execute a GraphQL mutation with inline values (for complex nested objects)
 * This is needed because gh CLI can't easily pass arrays of objects as variables
 *
 * @param {string} query - GraphQL mutation with inline values
 * @returns {object} The data portion of the GraphQL response
 */
function graphqlInline(query) {
  const escapedQuery = query.replace(/'/g, "'\\''");
  const cmd = `gh api graphql -f query='${escapedQuery}'`;

  const result = execSync(cmd, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
  const parsed = JSON.parse(result);

  if (parsed.errors) {
    const errorMsg = parsed.errors.map((e) => e.message).join('; ');
    throw new Error(errorMsg);
  }

  return parsed.data;
}

// =============================================================================
// Error Handling
// =============================================================================

/**
 * Check if an error indicates the resource already exists
 */
function isAlreadyExistsError(error) {
  const msg = error.message || '';
  return msg.includes('already been taken') || msg.includes('reserved') || msg.includes('already linked');
}

/**
 * Wrap a function to handle "already exists" errors gracefully
 */
function handleExistsError(fn, resourceName) {
  return async (...args) => {
    try {
      return await fn(...args);
    } catch (error) {
      if (isAlreadyExistsError(error)) {
        log.warn(`${resourceName} already exists or is reserved, skipping`);
        return null;
      }
      throw error;
    }
  };
}

// =============================================================================
// Project Operations
// =============================================================================

/**
 * Find an organization's project by title
 */
async function findProject(owner, title) {
  const data = graphql(
    `
      query ($owner: String!, $first: Int!) {
        organization(login: $owner) {
          projectsV2(first: $first) {
            nodes {
              id
              title
            }
          }
        }
      }
    `,
    { owner, first: 20 },
  );

  const project = data.organization?.projectsV2?.nodes?.find((p) => p.title === title);
  return project?.id || null;
}

/**
 * Create a new organization project
 */
async function createProject(projectConfig) {
  // Get organization ID
  const orgData = graphql(
    `
      query ($owner: String!) {
        organization(login: $owner) {
          id
        }
      }
    `,
    { owner: projectConfig.owner },
  );

  // Create the project
  const createData = graphql(
    `
      mutation ($ownerId: ID!, $title: String!) {
        createProjectV2(input: { ownerId: $ownerId, title: $title }) {
          projectV2 {
            id
          }
        }
      }
    `,
    { ownerId: orgData.organization.id, title: projectConfig.title },
  );

  return createData.createProjectV2.projectV2.id;
}

/**
 * Get all fields from a project
 */
async function getProjectFields(projectId) {
  const data = graphql(
    `
      query ($projectId: ID!) {
        node(id: $projectId) {
          ... on ProjectV2 {
            fields(first: 50) {
              nodes {
                ... on ProjectV2Field {
                  id
                  name
                  dataType
                }
                ... on ProjectV2SingleSelectField {
                  id
                  name
                  dataType
                  options {
                    id
                    name
                    color
                    description
                  }
                }
                ... on ProjectV2IterationField {
                  id
                  name
                  dataType
                }
              }
            }
          }
        }
      }
    `,
    { projectId },
  );

  return data.node.fields.nodes;
}

// =============================================================================
// Field Operations
// =============================================================================

/** Data type mapping from config to GitHub API */
const FIELD_TYPES = {
  single_select: 'SINGLE_SELECT',
  date: 'DATE',
  text: 'TEXT',
};

/**
 * Build a GraphQL single select option object
 */
function buildOption(option) {
  const name = escapeGraphQL(option.name);
  const color = option.color || 'GRAY';
  const description = escapeGraphQL(option.description || '');
  return `{ name: "${name}", color: ${color}, description: "${description}" }`;
}

/**
 * Create a field (generic for date/text types)
 */
async function createSimpleField(projectId, fieldConfig, dataType) {
  const data = graphql(
    `
      mutation ($projectId: ID!, $name: String!) {
        createProjectV2Field(
          input: { projectId: $projectId, dataType: ${dataType}, name: $name }
        ) {
          projectV2Field {
            ... on ProjectV2Field {
              id
            }
          }
        }
      }
    `,
    { projectId, name: fieldConfig.name },
  );

  return data.createProjectV2Field.projectV2Field.id;
}

/**
 * Create a single select field with options
 */
async function createSingleSelectField(projectId, fieldConfig) {
  const options = (fieldConfig.options || []).map(buildOption);

  if (options.length === 0) {
    throw new Error(`Single select field "${fieldConfig.name}" requires at least one option`);
  }

  const query = `
    mutation {
      createProjectV2Field(input: {
        projectId: "${projectId}",
        dataType: SINGLE_SELECT,
        name: "${escapeGraphQL(fieldConfig.name)}",
        singleSelectOptions: [${options.join(', ')}]
      }) {
        projectV2Field {
          ... on ProjectV2SingleSelectField {
            id
          }
        }
      }
    }
  `;

  const data = graphqlInline(query);
  return data.createProjectV2Field.projectV2Field.id;
}

/**
 * Update options on an existing single select field
 */
async function updateSingleSelectOptions(fieldId, desiredOptions, existingOptions) {
  const existingNames = new Set((existingOptions || []).map((o) => o.name));
  const missingOptions = desiredOptions.filter((o) => !existingNames.has(o.name));

  if (missingOptions.length === 0) {
    log.success('Options up to date');
    return;
  }

  log.info(`    Adding ${missingOptions.length} option(s): ${missingOptions.map((o) => o.name).join(', ')}`);

  // GitHub API replaces ALL options, so we must include existing + new
  // Note: API doesn't accept 'id' in input, options are matched by name
  const allOptions = [...(existingOptions || []), ...missingOptions].map(buildOption);

  const query = `
    mutation {
      updateProjectV2Field(input: {
        fieldId: "${fieldId}",
        singleSelectOptions: [${allOptions.join(', ')}]
      }) {
        projectV2Field {
          ... on ProjectV2SingleSelectField {
            id
          }
        }
      }
    }
  `;

  try {
    graphqlInline(query);
    log.success('Options updated');
  } catch (error) {
    log.warn(`Could not update options: ${error.message}`);
  }
}

/**
 * Create a field based on its type
 */
async function createField(projectId, fieldConfig) {
  const safeCreate = handleExistsError(async () => {
    switch (fieldConfig.type) {
      case 'single_select':
        return await createSingleSelectField(projectId, fieldConfig);
      case 'date':
      case 'text':
        return await createSimpleField(projectId, fieldConfig, FIELD_TYPES[fieldConfig.type]);
      default:
        log.warn(`Unknown field type: ${fieldConfig.type}`);
        return null;
    }
  }, `Field "${fieldConfig.name}"`);

  return safeCreate();
}

/**
 * Sync a single field (create if missing, update options if needed)
 */
async function syncField(projectId, fieldConfig, existingFields) {
  const existing = existingFields.find((f) => f.name === fieldConfig.name);

  if (existing) {
    log.field(fieldConfig.name, 'exists');

    // Update options for single select fields
    if (fieldConfig.type === 'single_select' && fieldConfig.options) {
      await updateSingleSelectOptions(existing.id, fieldConfig.options, existing.options);
    }
  } else {
    log.field(fieldConfig.name, 'creating...');
    await createField(projectId, fieldConfig);
  }
}

// =============================================================================
// Repository Operations
// =============================================================================

/**
 * Get all repositories linked to a project
 */
async function getLinkedRepositories(projectId) {
  const data = graphql(
    `
      query ($projectId: ID!) {
        node(id: $projectId) {
          ... on ProjectV2 {
            repositories(first: 50) {
              nodes {
                nameWithOwner
              }
            }
          }
        }
      }
    `,
    { projectId },
  );

  return data.node.repositories.nodes.map((r) => r.nameWithOwner);
}

/**
 * Verify that required repositories are linked to the project.
 * This script cannot link repositories (requires admin permissions).
 * If repositories are missing, it fails with instructions for an admin.
 *
 * @returns {string[]} List of missing repositories (empty if all linked)
 */
async function verifyRepositories(projectId, owner, requiredRepos) {
  const linkedRepos = await getLinkedRepositories(projectId);
  const linkedSet = new Set(linkedRepos.map((r) => r.toLowerCase()));

  const missing = [];
  for (const repo of requiredRepos) {
    const fullName = `${owner}/${repo}`.toLowerCase();
    if (linkedSet.has(fullName)) {
      log.success(`${owner}/${repo} is linked`);
    } else {
      log.error(`${owner}/${repo} is NOT linked`);
      missing.push(`${owner}/${repo}`);
    }
  }

  return missing;
}

/**
 * Print instructions for manually linking repositories
 */
function printLinkInstructions(projectTitle, missingRepos) {
  console.log('\n' + '='.repeat(70));
  console.log('ACTION REQUIRED: Repository linking requires admin permissions');
  console.log('='.repeat(70));
  console.log('\nThe following repositories need to be linked to the project:');
  missingRepos.forEach((repo) => console.log(`  - ${repo}`));
  console.log('\nTo fix this, an organization admin should:');
  console.log(`  1. Go to the "${projectTitle}" project settings`);
  console.log('  2. Click "Manage access" in the sidebar');
  console.log('  3. Under "Link a repository", add the missing repositories');
  console.log('\nAlternatively, use the GitHub CLI (requires admin permissions):');
  missingRepos.forEach((repo) => {
    console.log(`  gh project link <PROJECT_NUMBER> --owner epistola-app --repo ${repo.split('/')[1]}`);
  });
  console.log('\n' + '='.repeat(70));
}

// =============================================================================
// Main
// =============================================================================

async function main() {
  const { project, fields } = config;

  log.header('GitHub Project Sync');
  log.info(`Project: ${project.title}`);
  log.info(`Owner:   ${project.owner}`);

  // 1. Find or create project
  log.header('Project');
  let projectId = await findProject(project.owner, project.title);

  if (!projectId) {
    log.info('Creating project...');
    projectId = await createProject(project);
    log.success(`Created: ${projectId}`);
  } else {
    log.success(`Found: ${projectId}`);
  }

  // 2. Sync fields
  log.header('Fields');
  const existingFields = await getProjectFields(projectId);

  for (const field of fields) {
    await syncField(projectId, field, existingFields);
  }

  // 3. Verify repositories are linked (linking requires admin permissions)
  if (project.repositories?.length > 0) {
    log.header('Repositories');
    const missingRepos = await verifyRepositories(projectId, project.owner, project.repositories);

    if (missingRepos.length > 0) {
      printLinkInstructions(project.title, missingRepos);
      throw new Error(`${missingRepos.length} repository(ies) not linked to project`);
    }
  }

  log.header('Sync Complete');
}

main().catch((error) => {
  log.error(error.message);
  process.exit(1);
});
